# 行番号ベース分割方式への移行計画

## 1. 背景と課題

### 1.1 現状の方式

現在の NLP/AI モードは、セクション本文を **空行区切りで段落に分割** し、段落単位で分割点を決定している。

```
セクション本文
    ↓ 空行で分割
段落リスト [(start_line, end_line), ...]
    ↓ NLP: Jaccard 類似度 / AI: LLM に段落番号を送信
境界決定 → 仮想セクション生成
```

### 1.2 問題点

1. **巨大テーブルが分割されない**: 空行を含まないマークダウンテーブルは 1 段落として扱われ、数百行のテーブルでも分割対象にならない
2. **段落数 < 2 で再分割スキップ**: テーブルのみで構成されたセクションは段落数 1 となり、再分割条件 `len(paragraphs) < 2` で除外される
3. **子セクションを持つ親セクションが対象外**: 巨大テーブルの後にサブセクションがある場合、親セクション全体が再分割対象から外れる

### 1.3 影響範囲

- `_refine_sections`: 再分割の条件判定・制御フロー
- `_select_chunks_ai`: AI 境界決定（プロンプト・レスポンス処理）
- spec.md: 5 章（NLP モード制限事項追記）、6 章（AI モード）、3.3 節（再分割フェーズ）

---

## 2. AI モードの修正方針

### 2.1 概要

段落番号ベースから **行番号ベース** に移行する。セクション全体のテキストに行番号を付与して LLM に送信し、LLM は行番号ベースでグループ分けを返す。

### 2.2 行番号付与

git subtree として追加済みの [add-line-numbers](https://github.com/elvezjp/add-line-numbers) の `add_line_numbers_to_content()` 関数を使用する。自前で行番号付与ロジックを実装しない。

**インポートパス**: `add-line-numbers/add_line_numbers.py` の `add_line_numbers_to_content(content: str) -> tuple[str, int]`

**行番号フォーマット**: `{行番号:4d}: {行内容}`（右揃え4桁 + コロン + スペース）

```
   1: | 項目 | 説明 |
   2: |------|------|
   3: | A    | ...  |
   4: | B    | ...  |
```

**使用方法**:
- セクションの自身コンテンツ範囲のテキストを抽出し、`add_line_numbers_to_content()` に渡す
- 行番号は常に 1〜N（相対番号）で付与する。元ファイルの行番号ではない
- AI はこの相対番号で分割点を返し、レスポンス処理時に元ファイルの行番号に変換する（`実際の行番号 = own_start + 相対行番号 - 1`）
- 見出し行は含めない（セクション本文のみ）
- 空行にも行番号を付与する

### 2.3 プロンプトの変更

**システムプロンプト**:

| セクション | 変更内容 |
|-----------|---------|
| 役割 | 変更なし |
| 目的 | 「段落群」→「行番号付きテキスト」に変更。行範囲でグループ化する旨を記載 |
| 出力形式 | `start_paragraph` / `end_paragraph` → `start_line` / `end_line` に変更 |
| 注意事項 | 行の連続性・網羅性・非重複の制約に変更 |

**出力スキーマ**:

```json
[{"title": "...", "start_line": 1, "end_line": 14}, ...]
```

**ユーザーメッセージ**:
- 「以下のテキストを最大 N つのセクションに分割してください。」
- 行番号付きテキスト全文を送信

### 2.4 レスポンス検証

AI のレスポンスは 1 始まりの相対行番号として検証する：

- `start_line` が 1 以上であること
- `end_line` が N（コンテンツの総行数）以下であること
- 最初のグループの `start_line` が 1 と一致すること
- 最後のグループの `end_line` が N と一致すること
- 前のグループの `end_line + 1` が次のグループの `start_line` と一致すること（隙間なし・重複なし）

検証通過後、相対行番号を元ファイルの行番号に変換する: `実際の行番号 = own_start + 相対行番号 - 1`

### 2.5 コード変更箇所

| ファイル | メソッド/関数 | 変更内容 |
|---------|-------------|---------|
| `markdown_parser.py` | `_select_chunks_ai` | 段落番号ベース → 行番号ベースに書き換え。行番号付きテキストの構築、プロンプト更新、レスポンスパース・検証を行番号ベースに変更 |
| `markdown_parser.py` | `_refine_sections` | AI モード時に段落分割をスキップし、行範囲をそのまま `_select_chunks_ai` に渡すように変更。戻り値の chunks も行範囲ベースに |
| `markdown_parser.py` | `_build_virtual_sections_with_titles` | chunks の形式変更に対応（行範囲タプルのリストを受け取る） |

### 2.6 フォールバック

LLM 応答が不正または API エラーの場合は、従来と同様に閾値ベースの均等分割にフォールバックする。フォールバック時は行数ベースで均等に分割する。

---

## 3. NLP モードについて

### 3.1 方針

NLP モードは **現行の段落ベース方式を維持** し、巨大テーブルへの対応は行わない。

### 3.2 理由

- テーブル行はセルごとに数語程度しかなく、名詞集合がほぼ空か 1〜2 語になる
- Jaccard 類似度が実質的にランダムな結果となり、意味的な境界検出として機能しない
- 行単位に分解しても NLP の技術的優位性を活かせず、過剰な複雑化になる

### 3.3 制限事項（spec.md に追記）

以下を NLP モードの制限事項として明記する：

- 空行を含まない巨大テーブル等は 1 段落として扱われ、再分割の対象にならない
- テーブルを含むセクションの意味的分割が必要な場合は AI モード（`--split-mode ai`）の利用を推奨する

### 3.4 コード変更

NLP モードのコード変更は **なし**。

---

## 4. 共通の修正事項：親セクションの自身コンテンツ範囲の算出

### 4.1 課題

現状では子セクションを持つ親セクションは `id(section) in parent_ids` で一律スキップしている。しかし、親セクションの見出し直下に巨大なコンテンツ（テーブル等）がある場合にも再分割が必要となる。

```
## 仕様一覧          ← section.start_line
xxx...
[巨大テーブル]       ← 「自身のコンテンツ」= 再分割対象
                     ← own_content_end_line
### 補足1            ← 最初の子セクションの start_line
xxx...
### 補足2
xxx...               ← section.end_line
```

### 4.2 方針

`parent_ids` による一律スキップを廃止し、親セクションの **自身のコンテンツ範囲** を算出して再分割対象とする。

**自身のコンテンツ範囲の算出**:

```
own_content_start = section.start_line + 1（見出し行の次）
own_content_end   = 最初の子セクションの start_line - 1
```

- 子セクションを持たない末端セクションの場合: `own_content_end = section.end_line`（従来通り）
- 子セクションを持つ場合: 最初の子セクションの開始行の前行まで

### 4.3 再分割条件の変更

現在の条件:
1. 末端セクション（子セクションを持たない）であること ← **撤廃**
2. 文字数が `split_threshold` 以上
3. 段落数 2 以上（NLP モード）/ 行数 2 以上（AI モード）

変更後の条件:
1. **自身のコンテンツ範囲** の文字数が `split_threshold` 以上
2. NLP モード: 自身のコンテンツ範囲内の段落数が 2 以上
3. AI モード: 自身のコンテンツ範囲の行数が 2 以上

### 4.4 仮想セクション挿入の位置

親セクションの自身コンテンツ範囲のみを分割するため、仮想セクションは **子セクションの前** に挿入される。

```
## 仕様一覧              ← 元セクション（維持）
  ### テーブル前半        ← 仮想セクション 1（自身コンテンツの分割結果）
  ### テーブル後半        ← 仮想セクション 2（自身コンテンツの分割結果）
  ### 補足1              ← 既存の子セクション（変更なし）
  ### 補足2              ← 既存の子セクション（変更なし）
```

### 4.5 コード変更箇所

| ファイル | メソッド/関数 | 変更内容 |
|---------|-------------|---------|
| `markdown_parser.py` | `_refine_sections` | `parent_ids` スキップを廃止。各セクションの自身コンテンツ範囲を算出し、その範囲に対して再分割を実行。仮想セクションは子セクションの前に挿入 |
| `markdown_parser.py` | `_get_own_content_range` | 新規メソッド。セクションと sections リストから自身のコンテンツ範囲 `(own_start, own_end)` を返す |

### 4.6 フォールバック均等分割の改善

行番号ベースの AI モードでは、フォールバック時も行数ベースで均等に分割する（段落ベースではなく）。NLP モードのフォールバックは従来通り段落ベース。

---

## 5. 仕様書（spec.md）の更新

### 5.1 更新対象

| 章 | 更新内容 |
|----|---------|
| 2.3.6 分割モード | 再分割条件から「子見出しを持たない（末端セクション）」を撤廃し、「自身のコンテンツ範囲」ベースに変更 |
| 3.3 セクション再分割フェーズ | 自身コンテンツ範囲の算出ステップを追加。AI モードの境界決定を「行番号ベース」に変更 |
| 5.4 制限事項 | 巨大テーブル未対応・AI モード推奨の注記を追加 |
| 6.2 LLM への入力 | 段落番号 → 行番号ベースの入力形式に変更 |
| 6.3 LLM からの出力と検証 | `start_paragraph` / `end_paragraph` → `start_line` / `end_line` に変更 |

---

## 6. 実装順序

1. **`_refine_sections` の再分割条件を変更**
   - `parent_ids` スキップを廃止
   - `_get_own_content_range` メソッドを追加し、自身のコンテンツ範囲を算出
   - NLP/AI 両モードで自身のコンテンツ範囲のみを再分割対象にする
2. **`_select_chunks_ai` を行番号ベースに書き換え**
   - プロンプト構築（行番号付きテキスト生成）
   - レスポンスパース（`start_line` / `end_line`）
   - 検証ロジック（行番号の連続性・網羅性）
3. **spec.md 更新**
   - 2.3.6 節の再分割条件を更新
   - 3.3 節に自身コンテンツ範囲の算出ステップを追加
   - 5 章（NLP モード）に巨大テーブル未対応の制限事項を追記
   - 6 章（AI モード）を行番号ベースに更新
4. **テスト追加・既存テスト修正**
