# code2map 仕様書

## 1. 概要

code2map は、大規模なソースコードファイルを意味的な単位（クラス・メソッド・関数）に分割し、AI によるコードレビューや解析を支援するための「意味的マップ」を生成する CLI ツールである。

### 1.1 背景と目的

大規模なソースコードファイル（数千行規模）を AI でレビューする際、以下の課題が存在する：

- **コンテキスト制限**: AI モデルには入力トークン数の制限があり、巨大なファイル全体を一度に処理できない
- **構造把握の困難**: 長大なコードでは全体構造の把握が困難で、レビュー精度が低下する
- **参照の非効率性**: 特定のメソッドやクラスを参照する際、ファイル全体を読み直す必要がある

code2map はこれらの課題を解決するため、以下を提供する：

1. **構造化された索引（INDEX.md）**: コード全体の見取り図として機能し、シンボル間の関係性を把握可能にする
2. **分割されたコード片（parts/）**: 個別のシンボルを独立したファイルとして抽出し、焦点を絞ったレビューを可能にする
3. **機械可読な対応表（MAP.json）**: ツール連携や差分検知のための構造化データを提供する

### 1.2 設計思想

- **レビュー指向**: 分割されたコードはコンパイル・実行を目的としない。読みやすさと参照性を最優先とする
- **静的解析ベース**: AST（抽象構文木）に基づく解析を行い、正規表現による簡易解析は避ける
- **ヒューリスティック許容**: 呼び出し関係や副作用の検出は完全な正確性を保証しないが、実用的な情報を提供する
- **段階的拡張**: MVP（Minimum Viable Product）として単一ファイル解析から開始し、将来的にディレクトリ・プロジェクト単位の解析に拡張する

### 1.3 本ツールの対象外

code2map は「実行するための再構成」ではなく、**レビュー・解析のための再構成**を目的とする。以下の機能は明示的に対象外とする。

| 対象外機能 | 理由 |
|-----------|------|
| 分割後のソースをビルド可能にする | import 補完や依存解決を行うと複雑性が増し、本来の目的（可読性向上）から逸脱する |
| 依存解決（import 補完、参照先の自動統合） | 静的解析の範囲を超え、言語固有の複雑な処理が必要となる |
| フォーマッタや Linter の代替 | 既存ツール（Black、Prettier、ESLint 等）の領域であり、重複を避ける |
| 生成物を「正しい設計書」にする | 設計書は人間が別途用意するものであり、コードから自動生成される索引はあくまで参照用 |
| 実行時の動的解析 | 静的解析に特化し、実行環境への依存を排除する |

---

## 2. 機能要件

### 2.1 入力仕様

| 項目 | 仕様 |
|------|------|
| 対象ファイル | 単一のソースコードファイル |
| 対応言語 | Python（`.py`）、Java（`.java`） |
| エンコーディング | UTF-8（BOM なし）を前提 |
| 想定サイズ | 数百行から数千行（2000 行以上の大規模ファイルを想定） |

**スコープ制限（MVP）**:
- 単一ファイルのみを対象とする
- ディレクトリ単位・複数ファイル一括処理は将来拡張として扱う

### 2.2 出力仕様

ツールは指定された出力ディレクトリに以下の 3 種類の成果物を生成する。

#### 2.2.1 INDEX.md

人間および AI 向けの索引ファイル。Markdown 形式で記述される。

**ファイル構造**:

| 構成要素 | 必須/任意 | 説明 |
|---------|----------|------|
| ファイルヘッダ | 必須 | `# Index: <ファイル名>` 形式の見出し |
| 警告セクション | 任意 | パースエラー等がある場合のみ `[WARNING]` として記載 |
| Classes セクション | 任意 | クラス定義が存在する場合のみ |
| Methods セクション | 任意 | メソッド定義が存在する場合のみ |
| Functions セクション | 任意 | トップレベル関数が存在する場合のみ |

**各シンボルの記載項目**:

| 項目 | 説明 |
|------|------|
| ID | シンボルの一意識別子（`[CD1]` 形式で表示） |
| シンボル名 | クラス名、メソッド名（`ClassName#methodName` 形式）、関数名 |
| 行範囲 | 開始行と終了行（`L開始–L終了` 形式） |
| 分割ファイルリンク | parts/ 内の対応ファイルへの相対パス |
| role | Docstring / Javadoc から抽出した役割説明（最初の文） |
| calls | シンボル内で呼び出している他のメソッド・関数の一覧 |
| side effects | 検出された副作用（I/O、DB、ネットワーク等） |

**role / calls / side effects は情報が存在する場合のみ記載し、空の場合は省略する。**

#### 2.2.2 parts/ ディレクトリ

分割されたソースコード片を格納するディレクトリ。

**ファイル命名規則**:

| シンボル種別 | 命名パターン |
|-------------|-------------|
| クラス | `<ClassName>.class.<ext>` |
| メソッド | `<ClassName>_<methodName>.<ext>` |
| トップレベル関数 | `<functionName>.<ext>` |
| ネストクラス | `<OuterClass>_<InnerClass>.class.<ext>` |

**名前衝突の回避**:
- Java のメソッドオーバーロード等で同名シンボルが存在する場合、シグネチャまたは表示名の SHA-256 ハッシュ先頭 4 文字を付与する
- 例：`Foo_doWork__a1b2.java`

**各ファイルのヘッダ**:

ファイル先頭にメタデータをコメント形式で付与する。言語に応じたコメント記法を使用（Python: `#`、Java: `//`）。

| ヘッダ項目 | 説明 |
|-----------|------|
| fragment 宣言 | `code2map fragment (non-buildable)` - 非ビルド用である旨の明示 |
| id | シンボルの一意識別子（`{prefix}{連番}` 形式、例: `CD1`, `CD2`） |
| original | 元ファイルのパス |
| lines | 開始行-終了行の範囲 |
| symbol | シンボルの表示名 |
| notes | 依存情報と呼び出し先の要約（存在する場合） |

ヘッダの後に空行を挟み、元のソースコードを配置する。

**ID の形式**:
- プレフィックス（デフォルト: `CD`）+ 連番（1から開始）
- 連番は元ファイルでの出現順に付与
- プレフィックスは `--id-prefix` オプションで変更可能

#### 2.2.3 MAP.json

機械可読な対応表。JSON 配列形式で記述される。

**各エントリのフィールド**:

| フィールド | 型 | 説明 |
|-----------|------|------|
| id | string | シンボルの一意識別子（`{prefix}{連番}` 形式、例: `CD1`, `CD2`） |
| symbol | string | シンボルの表示名（`ClassName#methodName` 形式等） |
| type | string | シンボル種別（`"class"` / `"method"` / `"function"` のいずれか） |
| original_file | string | 元ファイル名（パスではなくファイル名のみ） |
| original_start_line | integer | 開始行番号（1-based） |
| original_end_line | integer | 終了行番号（inclusive） |
| part_file | string | 分割ファイルの相対パス（`parts/` プレフィックス付き） |
| checksum | string | SHA-256 チェックサム（16進数64文字、小文字） |

**id フィールドの用途**:
- 外部ツール連携時のシンボル参照に使用
- AI による構造マッチング時の確実なマッピングに利用
- 短く一意な識別子のため、LLM が正確に返却しやすい

**checksum の算出対象**:
- 分割ファイル全体（ヘッダコメントを含む）の内容を SHA-256 でハッシュ化

**配列の順序**:
- エントリは元ファイルでの出現順（開始行番号の昇順）で格納する

### 2.3 CLI 仕様

#### 2.3.1 コマンド構文

```
code2map build <input_file> [OPTIONS]
```

#### 2.3.2 引数・オプション

| 引数/オプション | 必須 | デフォルト | 説明 |
|----------------|------|-----------|------|
| `input_file` | 必須 | - | 解析対象のソースファイルパス |
| `--out <DIR>` | 任意 | `./code2map-out` | 出力ディレクトリパス |
| `--lang {java,python}` | 任意 | 自動検出 | 言語の明示指定 |
| `--id-prefix <PREFIX>` | 任意 | `CD` | シンボルIDのプレフィックス（例: `CD` → `CD1`, `CD2`, ...） |
| `--verbose` | 任意 | false | 詳細ログ出力の有効化 |
| `--dry-run` | 任意 | false | ファイル書き込みを行わずプレビューのみ |

#### 2.3.3 言語自動検出

`--lang` が省略された場合、ファイル拡張子から言語を判定する。

| 拡張子 | 言語 |
|--------|------|
| `.py` | Python |
| `.java` | Java |

上記以外の拡張子の場合はエラーとし、`--lang` オプションでの明示指定を促す。

#### 2.3.4 終了コード

| コード | 意味 |
|--------|------|
| 0 | 正常終了（警告なし） |
| 1 | 致命的エラー（ファイル不在、言語判定不可、パース失敗等） |
| 2 | 部分成功（警告ありだが出力は生成） |

#### 2.3.5 `--dry-run` 時の出力

ファイル書き込みを行わず、以下を標準出力に表示する：
- 検出したシンボル一覧（名前、種別、行範囲）
- 生成予定のファイル一覧

警告がある場合は標準エラー出力に出力する。

#### 2.3.6 出力ディレクトリの動作

| 状況 | 動作 |
|------|------|
| 出力ディレクトリが存在しない | 自動作成する |
| 出力ディレクトリが既に存在 | 既存ファイルを上書きする |
| parts/ サブディレクトリ | 同様に上書き動作 |

**注意**: code2map が生成しないファイル（ユーザーが手動配置したファイル等）は削除しない。

---

## 3. 処理フロー

### 3.1 全体フロー

```
入力ファイル受付
    ↓
言語判定（自動検出 or 明示指定）
    ↓
パーサー選択（Python AST / Java javalang）
    ↓
ソースコード解析 → シンボルリスト + 警告
    ↓
[dry-run?] → Yes → プレビュー出力して終了
    ↓ No
出力ディレクトリ作成
    ↓
parts/ 生成（コード片ファイル作成）
    ↓
INDEX.md 生成（索引ファイル作成）
    ↓
MAP.json 生成（対応表作成）
    ↓
終了（終了コード設定）
```

### 3.2 シンボル抽出フェーズ

パーサーはソースコードを AST に変換し、以下の情報を持つシンボルオブジェクトを抽出する。

**抽出対象**:
- クラス（トップレベル・ネスト）
- メソッド（インスタンスメソッド・クラスメソッド）
- 関数（トップレベルのみ、ネスト関数は親に含める）
- コンストラクタ（Java の場合、`<init>` として扱う）

**抽出情報**:

| 情報 | 説明 |
|------|------|
| 名前 | シンボルの識別名 |
| 種別 | class / method / function |
| 行範囲 | 開始行・終了行（1-based、inclusive） |
| 親シンボル | メソッドの所属クラス、ネストクラスの外部クラス |
| 修飾名 | 階層を含む完全名（例：`Parent.Child`） |
| 役割説明 | Docstring / Javadoc から抽出 |
| 呼び出し先 | コード内で検出した関数・メソッド呼び出し |
| 依存モジュール | import 文から抽出 |

### 3.3 コード片生成フェーズ

シンボルごとに以下の処理を行う：

1. **ファイル名決定**: 命名規則に従いファイル名を生成、衝突時はハッシュ付与
2. **コード抽出**: 元ファイルから該当行範囲を抽出
3. **ヘッダ生成**: メタデータをコメント形式で作成
4. **ファイル書き出し**: ヘッダ + コードを結合して出力

### 3.4 索引生成フェーズ

シンボルリストを基に INDEX.md を生成する。

**副作用検出**:
- 抽出したコード片に対してキーワードマッチングを実行
- 検出カテゴリ：ファイル I/O、標準出力、ログ出力、ネットワーク、DB、例外送出

### 3.5 対応表生成フェーズ

シンボルリストと生成済み parts/ ファイルの情報を基に MAP.json を生成する。

**チェックサム計算**:
- 各分割ファイルの内容全体を SHA-256 でハッシュ化
- 変更検知やキャッシュ管理に利用可能

---

## 4. 言語別対応範囲

### 4.1 Python

**解析基盤**: 標準ライブラリ `ast` モジュール

**対応構文**:

| 構文要素 | 対応状況 |
|---------|---------|
| クラス定義 | 対応（トップレベル・ネスト） |
| 関数定義 | 対応（トップレベルのみ分割対象） |
| メソッド定義 | 対応 |
| デコレータ | 認識（シンボルには含めない） |
| ネスト関数 | 親関数に含める（個別分割しない） |
| 非同期関数 | 対応 |

**メタデータ抽出**:
- Docstring：関数・クラス直下の文字列リテラルを取得、最初の行を role として使用
- 呼び出し関係：`ast.Call` ノードを走査して関数・メソッド呼び出しを抽出
- 依存関係：`import` / `from ... import` 文を解析

**制限事項**:
- 動的呼び出し（`eval`、`exec`、`getattr` による呼び出し）は検出不可
- 型アノテーションの詳細解析は行わない

### 4.2 Java

**解析基盤**: `javalang` ライブラリ

**対応構文**:

| 構文要素 | 対応状況 |
|---------|---------|
| クラス定義 | 対応（トップレベル・ネスト） |
| インターフェース定義 | 対応 |
| メソッド定義 | 対応 |
| コンストラクタ | 対応（`<init>` として扱う） |
| フィールド | 認識（シンボルとしては分割しない） |
| ネストクラス | 対応（`Outer_Inner` 形式で命名） |

**メタデータ抽出**:
- Javadoc：`/** ... */` コメントを取得、最初の文（ピリオドまたは改行まで）を role として使用
- 呼び出し関係：メソッド呼び出しノードを走査
- 依存関係：`import` 文を解析

**行範囲の決定**:
- `javalang` は終了行を提供しないため、ブレース（`{}`）のマッチングにより終了行を算出

**制限事項**:
- アノテーションの詳細解析は行わない
- ジェネリクス型パラメータの完全なマッピングは行わない
- リフレクションによる呼び出しは検出不可

---

## 5. 制約とヒューリスティック

### 5.1 分割コードの非実行性

- 分割されたコード片はコンパイル・実行を目的としない
- import 文の補完や依存解決は行わない
- ファイルヘッダに「非ビルド用」である旨を明記する

### 5.2 依存解析の限界

**calls（呼び出し関係）** と **side effects（副作用）** はヒューリスティックによる推定であり、以下の限界がある：

- 動的ディスパッチ（ポリモーフィズム）は考慮しない
- リフレクションによる呼び出しは検出不可
- 間接的な呼び出し（コールバック、イベント等）は検出不可

### 5.3 副作用検出キーワード

副作用は以下のカテゴリとキーワードパターンで検出する。

| カテゴリ | 検出対象キーワード例 |
|---------|---------------------|
| ファイル I/O | `open(`, `write`, `FileWriter`, `OutputStream` |
| 標準出力 | `print(`, `System.out` |
| ログ出力 | `logging.`, `logger.`, `log.` |
| ネットワーク | `http`, `socket`, `requests.`, `urllib` |
| DB 操作 | `execute`, `cursor`, `jdbc`, `save`, `commit` |
| 例外送出 | `raise`, `throw` |

**注意**: キーワードリストは固定（MVP）。将来的にユーザーカスタマイズ対応を検討する。

### 5.4 ネスト構造の扱い

**ネストクラス**:
- 個別のシンボルとして分割対象
- 命名規則：`OuterClass_InnerClass`
- 修飾名で階層関係を保持

**ネスト関数（Python）**:
- 親関数のシンボルに含める
- 個別ファイルへの分割は行わない
- 理由：ネスト関数は通常、親関数のスコープ内でのみ意味を持つため

---

## 6. エラーハンドリング

### 6.1 パースエラー時の動作

**方針**: 可能な限り部分的な出力を生成する

| 状況 | 動作 |
|------|------|
| 構文エラー検出 | 警告を記録し、抽出済みシンボルで出力生成を試行 |
| 完全なパース失敗 | 空のシンボルリストで出力生成（空の INDEX.md 等） |

**警告の記録先**:
- INDEX.md：`[WARNING]` コメントとして記載
- 標準エラー出力：`--verbose` 時に詳細を出力
- MAP.json：警告情報は含めない（スキーマ固定を優先）

### 6.2 ファイル I/O エラー

| エラー種別 | 動作 |
|-----------|------|
| 入力ファイル不存在 | エラーメッセージ出力、終了コード 1 |
| 出力ディレクトリ書き込み不可 | エラーメッセージ出力、終了コード 1 |
| エンコーディングエラー | 警告出力、置換文字（U+FFFD）で継続処理 |

### 6.3 エンコーディング処理

- 入力ファイルは UTF-8 を前提とする
- 非 UTF-8 文字は置換文字（`\ufffd`）に変換して処理を継続
- 置換が発生した場合は警告を出力

---

## 7. 非機能要件

### 7.1 パフォーマンス

- 数千行のファイルを数秒以内で処理可能であること
- メモリ効率を考慮し、必要に応じてストリーム処理を採用

### 7.2 拡張性

- 新言語対応は、パーサーモジュールの追加で実現可能なアーキテクチャとする
- パーサーは共通インターフェース（基底クラス）を継承する
- 将来的に Tree-sitter への移行を視野に入れた設計とする

### 7.3 動作環境

| 項目 | 要件 |
|------|------|
| Python バージョン | 3.9 以上 |
| 外部依存 | `javalang` ライブラリ（Java パース用） |
| OS | クロスプラットフォーム（Windows / macOS / Linux） |

---

## 8. 将来拡張

以下の機能は MVP 以降のフェーズで対応を検討する。

### 8.1 短期拡張（次期バージョン候補）

| 機能 | 概要 | 優先度 |
|------|------|--------|
| 複数ファイル対応 | ディレクトリ単位での一括解析、プロジェクト全体の索引生成 | 高 |
| 設定ファイル | 分割粒度、副作用検出キーワードのカスタマイズ（`.code2maprc` 等） | 高 |
| 差分解析 | 前回出力との比較、変更箇所の検出、変更影響度の可視化 | 中 |

### 8.2 中期拡張

| 機能 | 概要 | 備考 |
|------|------|------|
| 新言語追加 | TypeScript、Go、Rust、C++ | 需要に応じて優先順位を決定 |
| 意味的分割の強化 | 処理フェーズ単位の分割、例外・I/O 境界の抽出 | ヒューリスティックの改善が必要 |
| INDEX.md 品質向上 | 呼び出し関係のグラフ化（Mermaid 等）、依存の推定精度向上 | 可視化の改善 |

### 8.3 長期拡張

| 機能 | 概要 | 備考 |
|------|------|------|
| Tree-sitter 移行 | パフォーマンス・精度向上のための解析基盤変更 | 多言語対応の基盤として有効 |
| CI/CD 統合 | GitHub Actions での自動生成、PR ごとに索引生成・差分コメント | ワークフローテンプレートの提供 |
| Web UI | ブラウザ上での INDEX.md インタラクティブ閲覧 | 別リポジトリでの開発を検討 |
| IDE プラグイン | VSCode 等での統合、シンボルジャンプ機能 | 別リポジトリでの開発を検討 |

### 8.4 拡張時の設計方針

- **後方互換性**: 出力フォーマット（INDEX.md、MAP.json）のスキーマ変更は慎重に行い、既存ツール連携を壊さない
- **モジュール性**: 新言語パーサーは独立したモジュールとして追加可能な設計を維持
- **オプトイン**: 新機能は既存の動作を変更せず、オプションで有効化する形式を優先
